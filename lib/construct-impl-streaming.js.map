{"version":3,"sources":["../src/construct-impl-streaming.js"],"names":["_n","type","name","children","parent","ref","parentIsCx","__vnode_context","node","vnode","create","depth","pipe","c","_v","modify","_a","child","val"],"mappings":";;;;;;;;;AAAA;;AAEA;;AAEA;;AAEA;;;;AAEA;AAEO,SAASA,EAAT,CAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,QAAxB,EAAkC;AACxC;AACA;AACA,SAAO,wBAAM,UAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AACnC;;;;;;;;;AASA,UAAMC,aAAaF,OAAOG,eAA1B,CAVmC,CAWnC;;AACA,QAAIC,OAAOJ,OAAOK,KAAP,CAAaL,OAAOM,MAAP,CAAcT,IAAd,EAAoBC,IAApB,CAAb,EAAwCI,aAAa,IAAb,GAAoBF,MAA5D,EAAoEE,aAAa,CAAb,GAAiBF,OAAOO,KAAP,GAAe,CAApG,EAAuG,CAAvG,EAA0GV,IAA1G,CAAX,CAZmC,CAanC;;AACA,WAAOE,SAASS,IAAT,EACN;AACA,8BAAUC,KAAK,mBAAK,oBAAQA,CAAR,IAAa,OAAOA,EAAEL,IAAT,IAAiB,UAAjB,GAA8BK,EAAEL,IAAF,CAAOA,IAAP,CAA9B,GAA6CK,CAA1D,GAA8DC,GAAG,CAAH,EAAKD,IAAE,EAAP,EAAWL,IAAX,CAAgBA,IAAhB,CAAnE,CAAf,CAFM,EAGN,uBAAO,CAACA,IAAD,EAAMK,CAAN,KAAYL,KAAKO,MAAL,CAAYF,CAAZ,EAAcR,GAAd,CAAnB,EAAsCG,IAAtC,CAHM,CAAP;AAKA,GAnBM,EAmBJP,IAnBI,EAmBEC,IAnBF,CAAP;AAoBA;;AAEM,SAASc,EAAT,CAAYd,IAAZ,EAAkBe,KAAlB,EAAyB;AAC/B,SAAO,wBAAMb,UAAU;AACtB;AACA,QAAII,OAAOJ,OAAOK,KAAP,CAAaL,OAAOM,MAAP,CAAc,CAAd,EAAgBR,IAAhB,CAAb,EAAoCE,MAApC,CAAX,CAFsB,CAGtB;;AACA,WAAOa,MAAML,IAAN,CACN,0BAAUK,SAAST,KAAKO,MAAL,CAAY,oBAAQE,KAAR,IAAiB,OAAOA,MAAMT,IAAb,IAAqB,UAArB,GAAkCS,MAAMT,IAAN,CAAWA,IAAX,CAAlC,GAAqDS,KAAtE,GAA8EH,GAAG,CAAH,EAAKG,QAAM,EAAX,EAAeT,IAAf,CAAoBA,IAApB,CAA1F,CAAnB,CADM,CAAP;AAGA,GAPM,EAOJ,CAPI,EAODN,IAPC,CAAP;AAQA;;AAEM,SAASY,EAAT,CAAYb,IAAZ,EAAkBiB,GAAlB,EAAuB;AAC7B,SAAO,yBACN;AACAd,YAAUc,IAAIN,IAAJ,CAAS,oBAAIM,OAAOd,OAAOK,KAAP,CAAaL,OAAOM,MAAP,CAAcT,IAAd,EAAmBiB,GAAnB,CAAb,EAAsCd,MAAtC,CAAX,CAAT,CAFJ,EAGNH,IAHM,EAIN,IAJM,EAKNiB,GALM,CAAP;AAOA","sourcesContent":["import { map, concatMap, reduce } from \"rxjs/operators\";\r\n\r\nimport { isVNode } from \"./vnode\";\r\n\r\nimport vnode from \"./faux-vnode\";\r\n\r\nimport just from \"./just\";\r\n\r\n//import { isQName } from \"./qname\";\r\n\r\nexport function _n(type, name, children) {\r\n\t// Observable containing VNodes or strings\r\n\t// if either of the possibilities still contain Observables, they should be flattened elsewhere...\r\n\treturn vnode(function (parent, ref) {\r\n\t\t/*var ns;\r\n\t\tif (type == 1) {\r\n\t\t\tif (isQName(name)) {\r\n\t\t\t\tns = name;\r\n\t\t\t\tname = name.name;\r\n\t\t\t} else if (/:/.test(name)) {\r\n\t\t\t\t// TODO where are the namespaces?\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tconst parentIsCx = parent.__vnode_context;\r\n\t\t// convert to real VNode instance\r\n\t\tvar node = parent.vnode(parent.create(type, name), parentIsCx ? null : parent, parentIsCx ? 0 : parent.depth + 1, 0, type);\r\n\t\t// create an inode from each child by calling the inode function on the faux VNode\r\n\t\treturn children.pipe(\r\n\t\t\t// first test if node is observable, then if it's a VNode, else default to text\r\n\t\t\tconcatMap(c => just(isVNode(c) ? typeof c.node == \"function\" ? c.node(node) : c : _v(3,c+\"\").node(node))),\r\n\t\t\treduce((node,c) => node.modify(c,ref),node)\r\n\t\t);\r\n\t}, type, name);\r\n}\r\n\r\nexport function _a(name, child) {\r\n\treturn vnode(parent => {\r\n\t\t// provide a provisional entry in the parent (without a value)\r\n\t\tvar node = parent.vnode(parent.create(2,name), parent);\r\n\t\t// node is an attr node /w child as $val\r\n\t\treturn child.pipe(\r\n\t\t\tconcatMap(child => node.modify(isVNode(child) ? typeof child.node == \"function\" ? child.node(node) : child : _v(3,child+\"\").node(node)))\r\n\t\t);\r\n\t}, 2, name);\r\n}\r\n\r\nexport function _v(type, val) {\r\n\treturn vnode(\r\n\t\t// set by type, not by key (for attrs the keys are already filled in by pair)\r\n\t\tparent => val.pipe(map(val => parent.vnode(parent.create(type,val), parent))),\r\n\t\ttype,\r\n\t\tnull,\r\n\t\tval\r\n\t);\r\n}\r\n"],"file":"construct-impl-streaming.js"}