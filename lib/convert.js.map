{"version":3,"sources":["../src/convert.js"],"names":["toVNodeStream","inode","isLeaf","type","isBranch","isClose","VNodeBuffer","constructor","nodes","add","v","unshift","count","length","flush","$o","s","next","pop","$s","bufSize","cx","d","vnode","create","ndepth","stack","open","parents","openPairs","buffered","buf","checkStack","l","ol","last","parent","finalize","Close","node","name","key","_isBranch","undefined","push","depth","VNode","valueOf","value","JSON","parse","has","set","get","Observable","subscribe","cur","err","error","complete"],"mappings":"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","file":"convert.js","sourcesContent":["/**\r\n * Stream conversion\r\n * @module convert\r\n */\r\n\r\nimport { Observable } from \"rxjs\";\r\n\r\nimport * as inode from \"./inode\";\r\n\r\nimport { VNode, Close, getContext } from \"./vnode\";\r\n\r\n/**\r\n * Check if type is of leaf class\r\n * @param  {Number}  type the type constant to test\r\n * @return {Boolean}      result\r\n */\r\nexport const isLeaf = function isLeaf(type) {\r\n\treturn type == 2 || type == 3 || type == 4 || type == 7 || type == 8 || type == 10 || type == 12 || type == 16;\r\n};\r\n\r\n/**\r\n * Check if type is of branch class\r\n * @param  {Number}  type the type constant to test\r\n * @return {Boolean}      result\r\n */\r\nexport const isBranch = function isBranch(type) {\r\n\treturn type == 1 || type == 5 || type == 6 || type == 9 || type == 11 || type == 14 || type == 15;\r\n};\r\n\r\n/**\r\n * Check if type is of close class\r\n * @param  {Number}  type the type constant to test\r\n * @return {Boolean}      result\r\n */\r\nexport const isClose = type => type == 17;\r\n\r\nclass VNodeBuffer {\r\n\tconstructor(nodes = []) {\r\n\t\tthis.nodes = nodes;\r\n\t}\r\n\tadd(v) {\r\n\t\tthis.nodes.unshift(v);\r\n\t}\r\n\tcount() {\r\n\t\treturn this.nodes.length;\r\n\t}\r\n\tflush($o, count = 1) {\r\n\t\tlet s = this.count();\r\n\t\twhile (s >= count) {\r\n\t\t\t//console.log(\"FLUSH\",s,count);\r\n\t\t\t$o.next(this.nodes.pop());\r\n\t\t\t--s;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Convert an L3 stream directly to a VNode stream, constructing the document while traversing\r\n * An L3 stream is a sequence of L3 constants as integers, and names or values as strings (parsers are expected to emit this kind of stream).\r\n * @param  {Observable} $s       The L3 stream as an Observable\r\n * @param  {Number} [bufSize=1]  Optional buffer size. Use NaN or Infinity to buffer everything\r\n * @return {Observable}          The VNode stream as an Observable\r\n */\r\nexport function toVNodeStream($s,bufSize = 1) {\r\n\tconst cx = getContext(this,inode);\r\n\t// create fragment node here; doc constructor expects children\r\n\tlet d = cx.vnode(cx.create(11,\"#document-fragment\"), 11);\r\n\tlet ndepth = 0,\r\n\t\tstack = [],\r\n\t\topen = [11],\r\n\t\tparents = [d],\r\n\t\topenPairs = {},\r\n\t\tbuffered = null,\r\n\t\tbuf = new VNodeBuffer();\r\n\tconst checkStack = () => {\r\n\t\tvar l = stack.length;\r\n\t\tif (!l) return;\r\n\t\tvar type = stack[0];\r\n\t\tvar ol = open.length - 1;\r\n\t\tvar last = open[ol],\r\n\t\t\tparent = parents[ol];\r\n\t\t// buffered is used to add attributes to elements before they're emitted\r\n\t\t// here buffered is released before anything else is processed (except attrs)\r\n\t\tif (last == 1 && buffered !== null && type != 2) {\r\n\t\t\t// console.log(\"buf\",buffered.name);\r\n\t\t\tbuf.add(buffered);\r\n\t\t\tbuffered = null;\r\n\t\t}\r\n\t\tif (isClose(type)) {\r\n\t\t\topen.pop();\r\n\t\t\tparents.pop();\r\n\t\t\t//console.log(\"closing\",ndepth,parent.node);\r\n\t\t\t--ndepth;\r\n\t\t\tstack = [];\r\n\t\t\tparent.finalize();\r\n\t\t\treturn buf.add(new Close(parent));\r\n\t\t} else {\r\n\t\t\tlet node = void 0,\r\n\t\t\t\tname = void 0,\r\n\t\t\t\tkey = void 0,\r\n\t\t\t\t_isBranch = isBranch(type);\r\n\t\t\tif (_isBranch) {\r\n\t\t\t\tndepth++;\r\n\t\t\t\tswitch (type) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t{\r\n\t\t\t\t\tname = stack[1];\r\n\t\t\t\t\tnode = cx.create(1,name);\r\n\t\t\t\t\tif (last == 6) {\r\n\t\t\t\t\t\t// emit inode /w key\r\n\t\t\t\t\t\tkey = openPairs[ndepth];\r\n\t\t\t\t\t\t//console.log(\"picked up pair\",ndepth,key);\r\n\t\t\t\t\t\topenPairs[ndepth] = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (parent) parent.push([key, node]);\r\n\t\t\t\t\topen.push(type);\r\n\t\t\t\t\t// TODO use cx.vnode()\r\n\t\t\t\t\tlet depth = parent ? parent.depth + 1 : 1;\r\n\t\t\t\t\tlet vnode = new VNode(cx, node, type, name, key, isLeaf(type) ? node.valueOf() : null, parent, depth, parent ? parent.count() : 0);\r\n\t\t\t\t\t//let vnode = cx.vnode(node,parent,depth,parent ? parent.count() : 0,type);\r\n\t\t\t\t\t// buffer attributes\r\n\t\t\t\t\tbuffered = vnode;\r\n\t\t\t\t\t//console.log(\"opening element\",ndepth,name, buffered);\r\n\t\t\t\t\tparents.push(vnode);\r\n\t\t\t\t\tstack = [];\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tcase 9:\r\n\t\t\t\t\tnode = cx.create(9,\"#document\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 11:\r\n\t\t\t\t\tnode = cx.create(11,\"#document-fragment\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 14:\r\n\t\t\t\t\tnode = cx.create(14,stack[1]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 15:\r\n\t\t\t\t\tnode = cx.create(15);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 5:\r\n\t\t\t\t\tnode = cx.create(5);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 6:\r\n\t\t\t\t\t// never emit until all pairs are closed\r\n\t\t\t\t\tnode = cx.create(6);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (last == 6) {\r\n\t\t\t\t\t// must be an open pair\r\n\t\t\t\t\tkey = openPairs[ndepth - 1];\r\n\t\t\t\t\topenPairs[ndepth - 1] = undefined;\r\n\t\t\t\t\t//console.log(\"picked up pair\",ndepth,key);\r\n\t\t\t\t}\r\n\t\t\t\tif (parent) {\r\n\t\t\t\t\tparent.push([key, node]);\r\n\t\t\t\t}\r\n\t\t\t\topen.push(type);\r\n\t\t\t} else {\r\n\t\t\t\tif (type == 2) {\r\n\t\t\t\t\t// new model:\r\n\t\t\t\t\t// - create pair inode\r\n\t\t\t\t\t// - don't emit pair, but pair value /w key\r\n\t\t\t\t\topenPairs[ndepth] = stack[1];\r\n\t\t\t\t\t//console.log(\"opening pair\",ndepth,stack[1]);\r\n\t\t\t\t\tstack = [];\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet value = stack[1];\r\n\t\t\t\t\tif (type == 12) value = JSON.parse(value);\r\n\t\t\t\t\tnode = cx.create(type,value);\r\n\t\t\t\t\tif (openPairs[ndepth] !== undefined) {\r\n\t\t\t\t\t\tkey = openPairs[ndepth];\r\n\t\t\t\t\t\t//console.log(\"picked up pair\",ndepth,key);\r\n\t\t\t\t\t\t// NOTE unset pair! No seqs allowed in l3!\r\n\t\t\t\t\t\topenPairs[ndepth] = undefined;\r\n\t\t\t\t\t\tif (last == 6) {\r\n\t\t\t\t\t\t\tif (parent) {\r\n\t\t\t\t\t\t\t\tif(parent.has(key)) {\r\n\t\t\t\t\t\t\t\t\tparent.set(key,parent.get(key) + \" \"+ node);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tparent.push([key, node]);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (last == 1) {\r\n\t\t\t\t\t\t\tparent.set(key, value);\r\n\t\t\t\t\t\t\tstack = [];\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// error\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (parent) {\r\n\t\t\t\t\t\t\tparent.push([null, node]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstack = [];\r\n\t\t\tlet depth = parent ? parent.depth + 1 : type == 9 || type == 11 ? 0 : 1;\r\n\t\t\tlet vnode = new VNode(cx, node, type, name, key, isLeaf(type) ? node.valueOf() : null, parent, depth, parent ? parent.count() : 0);\r\n\t\t\t//let vnode = cx.vnode(node,parent,depth,parent ? parent.count() : 0,type);\r\n\t\t\tif (_isBranch) {\r\n\t\t\t\tparents.push(vnode);\r\n\t\t\t}\r\n\t\t\t//console.log(\"buf\",node.name);\r\n\t\t\tbuf.add(vnode);\r\n\t\t}\r\n\t};\r\n\treturn Observable.create($o => {\r\n\t\treturn $s.subscribe({\r\n\t\t\tnext: function next(cur) {\r\n\t\t\t\t// this will be the new version of streaming-fromL3!\r\n\t\t\t\tif (typeof cur == \"number\") {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tcheckStack();\r\n\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\treturn $o.error(err);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbuf.flush($o, bufSize);\r\n\t\t\t\t}\r\n\t\t\t\tstack.push(cur);\r\n\t\t\t},\r\n\t\t\tcomplete: function complete() {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcheckStack();\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\treturn $o.error(err);\r\n\t\t\t\t}\r\n\t\t\t\t// flush all\r\n\t\t\t\tbuf.flush($o);\r\n\t\t\t\t$o.complete();\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n"]}